<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Transcription</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* ... (keep existing styles) ... */
        :root { /* Define your colors */ }
        body { /* styles */ }
        .container { /* styles */ }
        .card { /* styles */ }
        /* ... other styles ... */

        /* Add styles for the progress area */
        #progressArea {
            margin-top: 20px;
            padding: 20px;
            background-color: var(--primary-3); /* Use your theme color */
            border-radius: 10px;
            text-align: center;
            display: none; /* Initially hidden */
        }
        #statusText {
            font-weight: 500;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        .progress { /* Bootstrap progress bar */
            height: 25px;
            font-size: 0.9rem;
        }
        #downloadArea {
             margin-top: 20px;
             text-align: center;
             display: none; /* Initially hidden */
        }
        .btn-download {
            background-color: #28a745; /* Green for success/download */
            border: 2px solid white;
             padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 10px;
            transition: background-color 0.3s ease;
            color: white;
            text-decoration: none; /* If using <a> tag */
        }
         .btn-download:hover {
            background-color: #218838;
        }
        /* Style for error messages */
        .error-message {
            color: #dc3545; /* Bootstrap danger color */
            font-weight: bold;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header">
                Audio Transcription Service
            </div>
            <div class="card-body">
                <!-- Upload Form Area -->
                <div id="uploadArea">
                    <form id="uploadForm" method="POST" enctype="multipart/form-data">
                         <label for="audio_file" class="upload-label">
                            Step 1: Choose Audio File
                            <input type="file" name="audio_file" id="audio_file" accept=".mp3,.mp4,.mpeg,.mpga,.m4a,.wav,.webm" required>
                         </label>
                         <div id="fileInfo" class="file-info">No file selected.</div>
                         <div class="btn-container">
                            <button type="submit" id="submitBtn" class="btn btn-primary" disabled>Step 2: Upload and Transcribe</button>
                         </div>
                    </form>
                </div>

                <!-- Progress Area -->
                <div id="progressArea">
                    <h5 id="progressTitle">Step 3: Processing Audio</h5>
                    <div id="statusText">Initializing...</div>
                    <div class="progress" role="progressbar" aria-label="Transcription Progress" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                        <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" style="width: 0%">0%</div>
                    </div>
                    <div id="errorMessage" class="error-message"></div> <!-- For displaying errors -->
                </div>

                <!-- Download Area -->
                <div id="downloadArea">
                     <h5 id="downloadTitle">Step 4: Download Complete</h5>
                     <p>Your transcript is ready!</p>
                     <a href="#" id="downloadLink" class="btn btn-download" download="transcript.txt">Download Transcript</a>
                </div>

            </div> <!-- End Card Body -->
        </div> <!-- End Card -->
    </div> <!-- End Container -->

    <script>
        const uploadForm = document.getElementById('uploadForm');
        const audioFile = document.getElementById('audio_file');
        const fileInfo = document.getElementById('fileInfo');
        const submitBtn = document.getElementById('submitBtn');

        const uploadArea = document.getElementById('uploadArea');
        const progressArea = document.getElementById('progressArea');
        const downloadArea = document.getElementById('downloadArea');

        const statusText = document.getElementById('statusText');
        const progressBar = document.getElementById('progressBar');
        const errorMessage = document.getElementById('errorMessage');
        const downloadLink = document.getElementById('downloadLink');

        let currentTaskId = null;
        let eventSource = null;

        // --- Client-side File Info & Validation ---
        audioFile.addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                // Basic Type Check (Supplement to 'accept' attribute)
                const allowedTypes = ['audio/mpeg', 'audio/mp4', 'audio/wav', 'audio/webm', 'audio/x-m4a']; // Add more specific types if needed
                if (!allowedTypes.includes(file.type) && !file.name.match(/\.(mp3|mp4|mpeg|mpga|m4a|wav|webm)$/i)) {
                    fileInfo.textContent = `Error: Invalid file type (${file.type || 'unknown'}). Allowed: MP3, MP4, M4A, WAV, WEBM`;
                    fileInfo.style.color = '#dc3545'; // Error color
                    submitBtn.disabled = true;
                    return;
                }

                // Size Check (Example: 2GB limit matching backend)
                const maxSize = 2 * 1024 * 1024 * 1024;
                if (file.size > maxSize) {
                     fileInfo.textContent = `Error: File too large (${(file.size / 1024**3).toFixed(2)} GB). Maximum size: 2 GB`;
                     fileInfo.style.color = '#dc3545';
                     submitBtn.disabled = true;
                     return;
                }

                // Display File Info & Enable Button
                fileInfo.style.color = 'white'; // Reset color
                fileInfo.textContent = `Selected: ${file.name} (${(file.size / 1024**2).toFixed(2)} MB)`;
                submitBtn.disabled = false;

                // Get Duration (Client-side estimate)
                const reader = new FileReader();
                reader.onload = function(e) {
                    const audio = new Audio();
                    audio.src = e.target.result; // Use Data URL
                    audio.onloadedmetadata = function() {
                        const duration = audio.duration;
                        if (isFinite(duration)) {
                            const minutes = Math.floor(duration / 60);
                            const seconds = Math.floor(duration % 60);
                            fileInfo.textContent += ` | Duration: ~${minutes}m ${seconds}s`;
                        }
                         URL.revokeObjectURL(audio.src); // Clean up object URL if used instead of Data URL
                    };
                     audio.onerror = function() {
                        console.warn("Could not determine audio duration client-side.");
                        URL.revokeObjectURL(audio.src);
                    };
                };
                 reader.readAsDataURL(file); // Read file for duration check

            } else {
                fileInfo.textContent = 'No file selected.';
                submitBtn.disabled = true;
            }
        });

        // --- Form Submission ---
        uploadForm.addEventListener('submit', function(event) {
            event.preventDefault(); // Stop default form submission

            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Uploading...';
            errorMessage.textContent = ''; // Clear previous errors

            const formData = new FormData(uploadForm);

            fetch('/upload', { // Send to the new upload endpoint
                method: 'POST',
                body: formData
            })
            .then(response => {
                if (!response.ok) {
                    // Handle HTTP errors (e.g., 500 Internal Server Error)
                    return response.json().then(err => { throw new Error(err.error || `Server error: ${response.status}`) });
                }
                if (response.status === 202) { // 202 Accepted - Task started
                     return response.json();
                } else {
                    throw new Error('Unexpected response from server.');
                }
            })
            .then(data => {
                if (data.task_id) {
                    currentTaskId = data.task_id;
                    console.log('Task started with ID:', currentTaskId);
                    // Switch UI
                    uploadArea.style.display = 'none';
                    progressArea.style.display = 'block';
                    downloadArea.style.display = 'none'; // Ensure download area is hidden
                    // Start listening for progress updates
                    startListeningForProgress(currentTaskId);
                } else {
                    throw new Error(data.error || 'Failed to start processing task.');
                }
            })
            .catch(error => {
                console.error('Upload Error:', error);
                errorMessage.textContent = `Upload failed: ${error.message}`;
                // Re-enable button and clear spinner if upload fails
                submitBtn.disabled = false;
                submitBtn.textContent = 'Step 2: Upload and Transcribe';
                // Show error in the progress area if it's visible, otherwise maybe use fileInfo area
                if (progressArea.style.display === 'block') {
                    statusText.textContent = 'Error';
                     progressBar.style.width = '100%';
                     progressBar.classList.add('bg-danger'); // Make progress bar red
                } else {
                     fileInfo.textContent = `Upload failed: ${error.message}`;
                     fileInfo.style.color = '#dc3545';
                }
            });
        });

        // --- Progress Monitoring (SSE) ---
        function startListeningForProgress(taskId) {
            console.log(`Connecting to SSE stream for task ${taskId}...`);
             // Close previous connection if any
            if (eventSource) {
                eventSource.close();
            }

            eventSource = new EventSource(`/stream-progress/${taskId}`); // Connect to the SSE endpoint

            eventSource.onmessage = function(event) {
                console.log("SSE Message:", event.data);
                const data = JSON.parse(event.data);
                updateProgressUI(data); // Update UI with received data
            };

            eventSource.onerror = function(error) {
                console.error('SSE Error:', error);
                statusText.textContent = 'Connection lost. Trying to reconnect...';
                // Optionally stop listening after too many errors or task completion
                // eventSource.close();
                // Maybe switch to polling as a fallback?
            };

             // Optional: Handle connection opening
             eventSource.onopen = function() {
                console.log("SSE connection opened.");
                 // Reset status if it was showing connection error
                 if (statusText.textContent.startsWith('Connection lost')) {
                     statusText.textContent = 'Reconnected. Resuming...';
                 }
            };
        }

        // --- Update UI based on Progress Data ---
        function updateProgressUI(data) {
            const state = data.state;
            const info = data.info || {}; // Metadata from backend
            const status = info.status || state; // Use specific status if available
            let percent = parseInt(info.percent, 10) || 0;

            errorMessage.textContent = ''; // Clear errors on new update unless it's a failure
            progressBar.classList.remove('bg-danger'); // Remove error styling

            statusText.textContent = status;

            if (state === 'PROGRESS') {
                percent = Math.max(0, Math.min(100, percent)); // Clamp percentage
                progressBar.style.width = percent + '%';
                progressBar.textContent = percent + '%';
                progressBar.setAttribute('aria-valuenow', percent);
            } else if (state === 'SUCCESS') {
                progressBar.style.width = '100%';
                progressBar.textContent = '100%';
                progressBar.setAttribute('aria-valuenow', 100);
                statusText.textContent = info.status || 'Processing Complete!';
                 // Prepare download link
                if (info.result_filename) {
                    downloadLink.href = `/download/${info.result_filename}`;
                    progressArea.style.display = 'none'; // Hide progress
                    downloadArea.style.display = 'block'; // Show download button
                } else {
                    statusText.textContent = 'Processing complete, but result file info missing.';
                }
                if (eventSource) eventSource.close(); // Stop listening

            } else if (state === 'FAILURE') {
                statusText.textContent = `Error: ${info.status || 'Processing failed'}`;
                errorMessage.textContent = `Details: ${info.status || 'Unknown error'}`;
                progressBar.style.width = '100%';
                progressBar.classList.add('bg-danger'); // Make bar red
                progressBar.textContent = 'Failed';
                 progressBar.setAttribute('aria-valuenow', 100); // Visually full, but red
                if (eventSource) eventSource.close(); // Stop listening

            } else if (state === 'PENDING') {
                 progressBar.style.width = '0%';
                 progressBar.textContent = '0%';
                 progressBar.setAttribute('aria-valuenow', 0);
                 statusText.textContent = info.status || 'Waiting in queue...';
            } else { // Other states like STARTED, RETRY
                statusText.textContent = info.status || state; // Display the state name
                 // Keep progress bar where it was or reset? Depends on desired UX.
            }
        }

        // --- Optional: Polling Fallback (if SSE isn't feasible/fails) ---
        // function pollTaskStatus(taskId) {
        //     const interval = setInterval(() => {
        //         fetch(`/status/${taskId}`)
        //             .then(response => response.json())
        //             .then(data => {
        //                 updateProgressUI(data);
        //                 if (data.state === 'SUCCESS' || data.state === 'FAILURE') {
        //                     clearInterval(interval); // Stop polling
        //                 }
        //             })
        //             .catch(error => {
        //                 console.error('Polling Error:', error);
        //                 statusText.textContent = 'Error checking status.';
        //                 // clearInterval(interval); // Optional: stop polling on error
        //             });
        //     }, 2000); // Poll every 2 seconds
        // }

    </script>
    <!-- Optional: Bootstrap JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>